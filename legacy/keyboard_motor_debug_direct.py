#!/usr/bin/env python3
"""
Generated by GPT
keyboard_motor_debug_direct_simple.py

Direct keyboard control of individual motors for debugging,
talking straight to motor_server (no RobotInterface in between).

Controls:
  1–8 : select active motor (ID 1–8)
  k   : increase angle of active motor (+5 deg)
  j   : decrease angle of active motor (-5 deg)
  SPACE : reset active motor to 150 deg (neutral)
  c   : reset ALL motors to 150 deg (neutral)
  q   : quit
"""

import sys
import termios
import tty
import select
import subprocess
from typing import List

DXL_RESOLUTION = 1023.0
DXL_MAX_DEGREES = 300.0
CENTER_DEG = 150.0  # neutral pose

STEP_DEG = 5.0


def deg_to_pos(deg: float) -> int:
    """Convert degrees (0–300) to Dynamixel position (0–1023)."""
    deg = max(0.0, min(DXL_MAX_DEGREES, deg))
    return int((deg / DXL_MAX_DEGREES) * DXL_RESOLUTION)


def _getch_blocking() -> str:
    """Blocking single-char read from stdin."""
    rlist, _, _ = select.select([sys.stdin], [], [], None)
    if not rlist:
        return ""
    return sys.stdin.read(1)


def main() -> None:
    motor_server_path = "../dynamixel_tools/motor_server"

    print(f"Starting motor_server at: {motor_server_path}")
    proc = subprocess.Popen(
        [motor_server_path],
        stdin=subprocess.PIPE,
        stdout=subprocess.DEVNULL,   # discard motor_server output
        stderr=subprocess.STDOUT,
        text=True,
        bufsize=1,
    )

    # Start with all joints at neutral (150 deg)
    joint_deg: List[float] = [CENTER_DEG] * 8
    active_index = 0  # 0..7

    print(
        "\n=== Keyboard Motor Debug (DIRECT SIMPLE) ===\n"
        "Controls:\n"
        "  1–8 : select active motor (ID 1–8)\n"
        "  k   : increase angle of active motor (+5 deg)\n"
        "  j   : decrease angle of active motor (-5 deg)\n"
        "  SPACE : reset active motor to 150 deg (neutral)\n"
        "  c   : reset ALL motors to 150 deg (neutral)\n"
        "  q   : quit\n\n"
        f"Active motor: {active_index + 1}\n"
    )

    fd = sys.stdin.fileno()
    try:
        old_settings = termios.tcgetattr(fd)
    except termios.error:
        print("[keyboard_motor_debug_direct_simple] stdin is not a TTY; keyboard control may not work.")
        return

    def send_positions():
        line = " ".join(str(deg_to_pos(d)) for d in joint_deg) + "\n"
        print(f"Sending positions to motor_server: {line.strip()}")
        try:
            assert proc.stdin is not None
            proc.stdin.write(line)
            proc.stdin.flush()
        except BrokenPipeError:
            print("motor_server exited unexpectedly.")

    try:
        tty.setcbreak(fd)

        # Send initial neutral pose
        send_positions()

        while True:
            ch = _getch_blocking()
            if not ch:
                continue

            # Quit
            if ch == "q":
                print("Quitting motor debug.")
                break

            # Select motor 1–8
            if ch in "12345678":
                active_index = int(ch) - 1
                print(f"Active motor: {active_index + 1}")

            # Increase / decrease active joint angle
            elif ch == "k":
                joint_deg[active_index] += STEP_DEG
                print(f"Motor {active_index + 1} -> {joint_deg[active_index]:.1f} deg")

            elif ch == "j":
                joint_deg[active_index] -= STEP_DEG
                print(f"Motor {active_index + 1} -> {joint_deg[active_index]:.1f} deg")

            # Reset active joint to neutral
            elif ch == " ":
                joint_deg[active_index] = CENTER_DEG
                print(f"Motor {active_index + 1} reset to {CENTER_DEG:.1f} deg (neutral)")

            # Reset all joints to neutral
            elif ch == "c":
                for i in range(8):
                    joint_deg[i] = CENTER_DEG
                print("All motors reset to neutral (150 deg).")

            # After any recognized key, send the updated positions ONCE
            if ch in "12345678kj c":
                send_positions()

    finally:
        # Restore terminal and stop motor_server
        try:
            termios.tcsetattr(fd, termios.TCSADRAIN, old_settings)
        except Exception:
            pass

        print("\nStopping motor_server...")
        if proc.stdin:
            try:
                proc.stdin.write("QUIT\n")
                proc.stdin.flush()
            except Exception:
                pass
        try:
            proc.wait(timeout=2.0)
        except Exception:
            pass
        print("motor_server stopped.")


if __name__ == "__main__":
    main()
