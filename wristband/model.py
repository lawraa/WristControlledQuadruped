# -*- coding: utf-8 -*-
"""wristband.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/126SyL6qUMwXdvypjcpBbbVbGEAydZptP
"""

import pandas as pd
import torch
import torch.nn as nn
import torch.nn.functional as F
import matplotlib.pyplot as plt
import numpy as np

from scipy.signal import butter, lfilter
from collections import deque

import glob

# -----------------------------
# Band-pass filter (stateful)
# -----------------------------
class BandpassEMG:
    def __init__(self, fs, low=20, high=450, level=4):
        nyq = fs / 2.0
        self.b, self.a = butter(level, [low / nyq, high / nyq], btype='band')
        # max(len(self.a, len(self.b) -1)) should be replaced by level - 1 (I think)
        self.zi = np.zeros(max(len(self.a), len(self.b)) - 1)

    def process(self, x):
        y, self.zi = lfilter(self.b, self.a, x, zi=self.zi)
        return y


# -----------------------------
# RMS envelope (stateful)
# -----------------------------
class RMSOnline:
    def __init__(self, fs, window_ms=50):
        self.N = int(fs * window_ms / 1000)
        self.buf = deque(maxlen=self.N)
        self.running_sum_of_squares = 0.0

    def process(self, x):
        out = np.zeros_like(x)
        for i, s in enumerate(x):
            if len(self.buf) == self.N:
                self.running_sum_of_squares -= self.buf[0] ** 2
            self.buf.append(s)
            self.running_sum_of_squares += s ** 2
            out[i] = np.sqrt(self.running_sum_of_squares / len(self.buf))
        return out

fs = 10000  # Hz
duration = 2.0
t = np.arange(0, duration, 1/fs)

# Fake EMG-like signal
raw_emg = 0.05 * np.random.randn(len(t))
raw_emg += 0.3 * np.sin(2 * np.pi * 100 * t) * (t > 0.5)

# Create pipeline
bp = BandpassEMG(fs)
rms = RMSOnline(fs, window_ms=50)

# Simulate streaming in chunks
chunk_size = 64
filtered = []
envelope = []

for i in range(0, len(raw_emg), chunk_size):
    chunk = raw_emg[i:i+chunk_size]
    y = bp.process(chunk)
    e = rms.process(y)
    filtered.append(y)
    envelope.append(e)

filtered = np.concatenate(filtered)
envelope = np.concatenate(envelope)

# -----------------------------
# Plot
# -----------------------------
plt.figure(figsize=(10,6))
plt.subplot(3,1,1)
plt.plot(t, raw_emg)
plt.title("Raw EMG")

plt.subplot(3,1,2)
plt.plot(t, filtered)
plt.title("Band-pass filtered (20â€“450 Hz)")

plt.subplot(3,1,3)
plt.plot(t, envelope)
plt.title("RMS Envelope (50 ms)")

plt.tight_layout()
plt.show()

def normalize_input(x: np.ndarray):
  return x / x.max()

# Define path were emg data is stored into folders belonging to each class (Task1, Task2, ...)
MAIN_PATH = "../Data/RmsNorm_Reg/two_sec"
# Define path to save generated features
FEATURES_PATH = "../Features"

# List containing the name of each folder representing each class
CLASS_DICT = {
    "Class1": 1,
    "Class2": 2,
    "Class3": 3,
    "Class4": 4,
    "Class5": 5,
    "Class6": 6
}

# Define type of features: MeanAbsoluteValue, MeanAbsWeightI, MeanAbsWeightII, MedianAbsValue, Variance, StdDeviation.
# In case you want to add a feature, you should generate your own function and add the case on the function: get_custom_features()
FEATURES = ["MeanAbsValue", "MeanAbsWeight0.5", "MeanAbsWeight2", "Variance", "Max", "Min"]

EMG_SENSORS = ["SENS1", "SENS2", "SENS3", "SENS4"]

def mean_abs_value_with_bias(data: pd.Series, weight: float = 1.0, window_length = 0.25) -> float:
  if (weight == 1.0):
    return abs(data).mean()

  values_list = []
  for id in range(len(data)):
    if id + 1 <= (1-window_length)*len(data) and id + 1 >= window_length*len(data):
      w = 1
    else:
      w = weight
    values_list.append(abs(data.iloc[id])*w)
  return np.mean(values_list)

def variance(data: pd.Series):
  variance = data.var()
  return variance

def max(data: pd.Series):
  return data.max()

def min(data: pd.Series):
  return data.min()

FEATURES_LIST = []

FEATURES_LIST.append("Target")
for feature in FEATURES:
    for sensor in EMG_SENSORS:
        FEATURES_LIST.append(f"{feature}_{sensor}")

def main(path: str) -> pd.DataFrame:
    """
    This function iterates through the path containing all
    emg files and calculate the different features for each
    emg sensor.
    Params:
        path (str): path to the folders containing all emg files.
    Returns:
        df_features (Dataframe): contains features from all files
    """
    # Define main dataframe to store calculated features
    df_features = pd.DataFrame(columns=FEATURES)
    # Iterate through emg files in path
    for file in glob.iglob(os.path.join(path, "*/*.csv")):
        emg_file = pd.read_csv(file, index_col = 0)
        feature_file = {}
        # Iterate through each emg sensor
        for sensor in EMG_SENSORS:
            # Iterate through each feature type
            for feature in FEATURES_LIST:
                match feature:
                    case "MeanAbsoluteValue":
                        value = mean_abs_value(emg_file[sensor])
                    case "MeanAbsWeightI":
                        value = mean_abs_weightI(emg_file[sensor])
                    case "MeanAbsWeightII":
                        value = mean_abs_weightII(emg_file[sensor])
                    case "MedianAbsValue":
                        value = median_abs_value(emg_file[sensor])
                    case "Variance":
                        value = variance(emg_file[sensor])
                    case "StdDeviation":
                        value = std_deviation(emg_file[sensor])
                    case _:
                        value = np.nan
                        print("Feature doesn't exist")
                # Store task label
                feature_file["Label"] = MOTOR_TASKS_DIC[file.split("\\")[-2]]
                # Store calculated feature in dict
                feature_file[f"{feature}_{sensor}"] = (value)
        # Append emg file features in dataframe
        df_features = df_features.append(feature_file, ignore_index=True)
    return df_features

# Add remaining code 